// Group Number: 31
// MADHUR PANWAR   2016B4A70933P
// TUSSANK GUPTA   2016B3A70528P
// SALMAAN SHAHID  2016B4A70580P
// APURV BAJAJ     2016B3A70549P
// HASAN NAQVI     2016B5A70452P

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "hash.h"
#include "parserDef.h"
#include "parser.h"
#include "set.h"
#include "util.h"
#include "config.h"
#include "lexer.h"
#include "errorPtr_stack.h"
#include "typeCheck.h"

#include "astDef.h"
#include "ast.h"
#include "symbolHash.h"
#include "symbolTable.h"
#include "archive.h"
#include "codeGen.h"



//destroy trees, close if open, do not close STDOUT

// Variables defined in lexer.c
extern unsigned int fp;
extern unsigned int bp;
extern unsigned int line_number;
extern int status;
extern int count;
extern hashTable *keyword_ht;

// Variables defined in parser.c
extern grammarNode *grammarArr;
extern struct hashTable *mt;
extern intSet* firstSet;
extern intSet* followSet;
extern char *inverseMappingTable[];
extern int **parseTable;
errorPtr_stack *errorStack;

// error flags
extern bool stage1ErrorFree;
extern bool haveSemanticErrors;

// variables defined in symbolTable.c
extern symbolTable funcTable;

int main(int argc, char *argv[]) {
//    printf("%d",sizeof(symbolTable));
    if(argc != 3) {
        printf("Usage: %s <source code file> <assembly code output file>\n", argv[0]);
        exit(1);
    }

    printf("\t FIRST and FOLLOW set automated. \n");
    printf("\t Both lexical and syntax analysis modules implemented. \n");
    printf("\t Modules work with all testcases. \n");
    printf("\t Source code is parsed successfully. \n");
    printf("\t Parse tree is printed in the output file. \n");
    printf("\t Error detection and recovery done. \n\n");

    mt = createHashTable(SYMBOL_HT_SIZE); // 131 is the nearest prime > 114 (# of symbols (NT + T))
    fillHashTable(inverseMappingTable,mt);

    // Create and populate hash table for keywords
    keyword_ht = createHashTable(KEYWORD_HT_SIZE);

    char* keywords[] = {
        #define K(a,b,c) c,
        #include "keywords.txt"
        #undef K
        "#"
    };

    fillHashTable(keywords,keyword_ht);

    populateGrammarStruct("grammar.txt");

//     printGrammar();

    populateFirstSet();
    populateFollowSet();
    populateParseTable();
    modifyParseTable_Err_Recovery();

//    printParseTable();

    char userInput;

    while(1) {
        printf("\n\t Press 0 to exit."
               "\n\t Press 1 to print the token list generated by the lexer (on the console)."
               "\n\t Press 2 to parse the input source code and to print parse tree (on the console)."
               "\n\t Press 3 to build and print the Abstract Syntax Tree (on the console)."
               "\n\t Press 4 to print the memory usage by Parse Tree and AST and to find compression percentage."
               "\n\t Press 5 to build and print Symbol Table."
               "\n\t Press 6 to print Activation Record sizes of every function."
               "\n\t Press 7 to print the type expressions and width of array variables ."
               "\n\t Press 8 to report errors and display total compiling time."
               "\n\t Press 9 to generate assembly code."
               "\n\t Press # to build and printSymTable1 (testing)."
               "\n\t Press $ to build and printSymTable2 (testing)."
               "\n\t Press q to remove comments.\n");


        scanf(" %c", &userInput);
        switch(userInput) {

            case '0':
                return 0;
                break;

            case 'q':
                removeComments(argv[1], NULL);
                break;

            case '1':
            {
                FILE *fp_arg = fopen(argv[1], "r");
                tokenInfo *tk;

                printf("%12s %20s %20s \n", "Line_number", "lexeme", "Token_name");

                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;
                while((tk = getNextToken(fp_arg)) != NULL) {
                    printf("%12d %20s %20s\n", tk->lno, tk->lexeme, inverseMappingTable[tk->type]);
                    free(tk);
                }
                fcloseSafe(fp_arg);
            } break;

            case '2':
            {
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;

                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack
                printTree(root, NULL);   //printTree also frees the tree after printing it.
                // passing NULL prints on stdout instead of in a file. Pass a file name to print in that file
                destroyTree(root);
            }
            break;



            case '3':
            {
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;

                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack
                if(!stage1ErrorFree) {
                    printf("The given source code has syntactic errors. Cannot print Abstract Syntax Tree.\n");
                    break;
                }
                ASTNode *ASTroot = buildASTTree(root);
                if(!ASTroot) {
                    printf("Trivial source code. AST is empty. Hence, cannot print AST.\n");
                    break;
                }
                printf("\t The following AST has been printed in inorder traversal order:"
                       "\n\t We print the leftmost child recursively then the parent then all remaining children.\n");
                print_Inorder_ASTTree(ASTroot, NULL); // NULL prints to console, pass a file name to print in the file
//                print_ASTTree(ASTroot, NULL); // NULL prints to console, pass a file name to print in the file

                destroyAST(ASTroot);
                destroyTree(root);
            }
            break;
            case '4':{
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;

                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack
                int numParseNodes = count_nodes_parseTree(root);
                unsigned long memParseTree = numParseNodes * sizeof(treeNode);
                printf("%-27s %-1s %-10d %-20s %-10lu\n", "Parse tree Number of nodes ","=",numParseNodes, "Allocated Memory =",memParseTree);
                if(!stage1ErrorFree) {
                    printf("The given source code has syntactic errors. Cannot compute memory usage by Abstract Syntax Tree.\n");
                    break;
                }
                ASTNode *ASTroot = buildASTTree(root);
                if(!ASTroot) {
                    printf("Trivial source code. AST is empty. Hence, cannot compute its memory usage.\n");
                    break;
                }
                int numASTNodes = count_nodes_ASTTree(ASTroot);
                unsigned long memAST = numASTNodes * sizeof(ASTNode);
                printf("%-27s %-1s %-10d %-20s %-10lu\n", "AST Number of nodes ","=",numASTNodes, "Allocated Memory =",memAST);
                double comprPct = ((double )(memParseTree - memAST)/(double)memParseTree)*100.0;
                printf("Compression percentage = %lf\n", comprPct);

                destroyTree(root);
                destroyAST(ASTroot);
            }
            break;


            case '5':
            {
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;

                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack
                if(!stage1ErrorFree) {
                    printf("The given source code has syntactic errors. Cannot print Symbol Table.\n");
                    break;
                }
                ASTNode *ASTroot = buildASTTree(root);

                if(!ASTroot) {
                    printf("Trivial source code. AST is empty. Hence, Symbol Table is also empty.\n");
                    break;
                }

                buildSymbolTable(ASTroot);
                if(!haveSemanticErrors){
                    printf("Input source code is semantically correct and type checked..........\n");
                }
                printSymbolTable(&funcTable,NULL);// NULL prints to console, pass a file name to print in the file

                destroySymbolTable(&funcTable,true);
                destroyAST(ASTroot);
                destroyTree(root);
            }
            break;
            case '6':
            {
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;
                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack
                if(!stage1ErrorFree)
                    printf("The given source code has syntactic errors. Cannot print Activation Record Sizes.\n");
                ASTNode *ASTroot = buildASTTree(root);

                if(!ASTroot) {
                    printf("Trivial source code. AST is empty. Hence, AR sizes are undefined.\n");
                    break;
                }

                buildSymbolTable(ASTroot);
                if(!haveSemanticErrors){
                    printf("Input source code is semantically correct and type checked..........\n");
                }

                printARSizes(&funcTable,NULL); // NULL prints to console, pass file name to print in the file

                destroySymbolTable(&funcTable,true);
                destroyAST(ASTroot);
                destroyTree(root);
            }
            break;
            case '7':
            {
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;

                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack
                if(!stage1ErrorFree) {
                    printf("The given source code has syntactic errors. Cannot print array information.\n");
                    break;
                }
                ASTNode *ASTroot = buildASTTree(root);


                if(!ASTroot) {
                    printf("Trivial source code. AST is empty. Hence, there is no array information to be printed.\n");
                    break;
                }

                buildSymbolTable(ASTroot);
                if(!haveSemanticErrors){
                    printf("Input source code is semantically correct and type checked..........\n");
                }

                printArrayInfo(&funcTable,NULL);// NULL prints to console, pass a file name to print in the file

                destroySymbolTable(&funcTable,true);
                destroyAST(ASTroot);
                destroyTree(root);
            }
            break;
            case '8':
            {
                clock_t start_time, end_time;
                double total_CPU_time, total_CPU_time_in_seconds;

                start_time = clock();

                //__________________________________________________
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;

                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack

                if(!stage1ErrorFree)
                    break;

                ASTNode *ASTroot = buildASTTree(root);
                if(!ASTroot) {
                    printf("Trivial source code. AST is empty. Hence, cannot proceed for building symbol table.\n");
                    break;
                }

                buildSymbolTable(ASTroot);
                if(!haveSemanticErrors){
                    printf("Input source code is semantically correct and type checked..........\n");
                }

                //____________________________________________________
                end_time = clock();

                total_CPU_time  =  (double) (end_time - start_time);
                total_CPU_time_in_seconds =   total_CPU_time / CLOCKS_PER_SEC;

                printf("Total CPU time = %lf \nTotal CPU time in secs = %lf \n", total_CPU_time, total_CPU_time_in_seconds);
                destroySymbolTable(&funcTable,true);
                destroyAST(ASTroot);
                destroyTree(root);
            }
                break;
            case '9':
            {
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;

                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack

                if(!stage1ErrorFree)
                    break;
                ASTNode *ASTroot = buildASTTree(root);


                if(!ASTroot) {
                    printf("Trivial source code. AST is empty. Hence, assembly code cannot be generated.\n");
                    break;
                }

                buildSymbolTable(ASTroot);
                if(!haveSemanticErrors){
                    printf("Input source code is semantically correct and type checked..........\n");
                    FILE *fpout = fopen(argv[2],"w");
                    generateCode(ASTroot, &funcTable, fpout);
                    fcloseSafe(fpout);
                }
                printf("Code compiles successfully..........\n");
                destroySymbolTable(&funcTable,true);
                destroyAST(ASTroot);
                destroyTree(root);

            }
            break;

            // TODO: Leave the below as it is. These are for testing. Just remove their menu options from the print menu.
            case '#':
            {
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;
                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack

                if(!stage1ErrorFree)
                    break;
                ASTNode *ASTroot = buildASTTree(root);

                extern symbolTable funcTable;
//                makeSampleSymTableForTest(&funcTable);
                buildSymbolTable(ASTroot);

                if(ASTroot != NULL) {
                    printf("symbol table built\n");
                }

                printSymbolTable1(&funcTable,NULL); // NULL prints to console, pass file name to print in the file

            }
            break;
            case '$':
            {
                // Initialise lexer every time.
                fp = 0; bp = 0; line_number = 1; status = 1; count = 0;
                treeNode *root = parseInputSourceCode(argv[1]); //this also frees the error stack

                if(!stage1ErrorFree)
                    break;
                ASTNode *ASTroot = buildASTTree(root);

                extern symbolTable funcTable;
//                makeSampleSymTableForTest(&funcTable);
                buildSymbolTable(ASTroot);

                if(ASTroot != NULL) {
                    printf("symbol table built.\n");
                }

                printSymbolTable2(&funcTable, NULL);// NULL prints to console, pass file name to print in the file

            }
            break;
            default:
                printf("Invalid Choice. Please try again! \n");
        }

    }

    return 0;
}
